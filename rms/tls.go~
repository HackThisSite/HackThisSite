package main

import (
	"fmt"
	"crypto/tls"
	"crypto/rand"
	"os"
	"net"
	"exec"
	"big"
)

func main() {
	cert, err := tls.LoadX509KeyPair("./certificate.cert", "./privkey.key")
	handleErr(err)
	
	hostname, err := os.Hostname();handleErr(err)
	config := tls.Config{rand.Reader, nil, []tls.Certificate{cert}, nil, []string{}, 
		hostname, true, nil}
	
	listener, err := tls.Listen("tcp", ":51064", &config)
	handleErr(err)
	
	for true {
		conn, err := listener.Accept();handleErr(err)
		fmt.Println("New connection from", conn.RemoteAddr().String())
		go client(conn)
	}
}

func client(conn net.Conn) {
	err := conn.VerifyHostname()
	if err != nil {
		fmt.Println("Error: ", err)
		return
	}
	
	err = conn.SetTimeout(1000000000);handleErr(err)
	
	bytes := make([]byte, 1024)
	_, err = conn.Read(bytes)
	if err != nil {
		fmt.Println("Connection failed with", conn.RemoteAddr().String())
		return
	}
	
	serverId := compliment(bytes[0:2])
	userId := compliment(bytes[2:14])
	missionId := compliment(bytes[14:26])
	
	path, err := exec.LookPath("php");handleErr(err)
	cmd := exec.Command(path, "./auth.php", conn.RemoteAddr().String(), 
		serverId, userId, missionId)
	output, err := cmd.Output();handleErr(err)
	
	if string(output) == "true" {
		fmt.Print("Notice: Successfully marked mission.  ")
		_, err = conn.Write([]byte{1})
	} else {
		fmt.Print("Error:  Access denied to mark mission.  ")
		_, err = conn.Write([]byte{0})
	}
	
	fmt.Println(serverId, "-", userId, "-", missionId)
	
	if err != nil {
		fmt.Println("Notice:", err)
		return
	}
}

func compliment(bytes []byte) string {
	top := len(bytes) - 1
	sum := big.NewInt(0)
	pos := 0
	
	for top >= 0 {
		temp1 := big.NewInt(0)
		temp2 := big.NewInt(0)
		
		temp1.Exp(big.NewInt(256), big.NewInt(int64(top)), nil)
		temp2.Mul(big.NewInt(int64(bytes[pos])), temp1)
		sum.Add(sum, temp2)
		top = top - 1
		pos = pos + 1
	}
	
	return sum.String()
}

func handleErr(err os.Error) {
	if err != nil {
		fmt.Println("Fatal: ", err)
		os.Exit(1)
	}
}
